{"ast":null,"code":"import { compose, ScannedActionsSubject, Store, createAction, StoreRootModule, StoreFeatureModule } from '@ngrx/store';\nimport { merge, Observable, Subject, defer, Notification, pipe, of } from 'rxjs';\nimport { ignoreElements, materialize, map, catchError, filter, groupBy, mergeMap, exhaustMap, dematerialize, take, concatMap, finalize, withLatestFrom } from 'rxjs/operators';\nimport { Injectable, Inject, InjectionToken, ErrorHandler, NgModule, Optional, Injector, SkipSelf, Self } from '@angular/core';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from 'rxjs';\nimport * as ɵngcc2 from '@ngrx/store';\nconst DEFAULT_EFFECT_CONFIG = {\n  dispatch: true,\n  useEffectsErrorHandler: true\n};\nconst CREATE_EFFECT_METADATA_KEY = '__@ngrx/effects_create__';\n\n/**\n * @description\n * Creates an effect from an `Observable` and an `EffectConfig`.\n *\n * @param source A function which returns an `Observable`.\n * @param config A `Partial<EffectConfig>` to configure the effect.  By default, `dispatch` is true and `useEffectsErrorHandler` is true.\n * @returns If `EffectConfig`#`dispatch` is true, returns `Observable<Action>`.  Else, returns `Observable<unknown>`.\n *\n * @usageNotes\n *\n * ** Mapping to a different action **\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(FeatureActions.actionOne),\n *     map(() => FeatureActions.actionTwo())\n *   )\n * );\n * ```\n *\n *  ** Non-dispatching effects **\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(FeatureActions.actionOne),\n *     tap(() => console.log('Action One Dispatched'))\n *   ),\n *   { dispatch: false }\n *   // FeatureActions.actionOne is not dispatched\n * );\n * ```\n */\nfunction createEffect(source, config) {\n  const effect = source();\n  const value = Object.assign(Object.assign({}, DEFAULT_EFFECT_CONFIG), config);\n  Object.defineProperty(effect, CREATE_EFFECT_METADATA_KEY, {\n    value\n  });\n  return effect;\n}\nfunction getCreateEffectMetadata(instance) {\n  const propertyNames = Object.getOwnPropertyNames(instance);\n  const metadata = propertyNames.filter(propertyName => {\n    if (instance[propertyName] && instance[propertyName].hasOwnProperty(CREATE_EFFECT_METADATA_KEY)) {\n      // If the property type has overridden `hasOwnProperty` we need to ensure\n      // that the metadata is valid (containing a `dispatch`property)\n      // https://github.com/ngrx/platform/issues/2975\n      const property = instance[propertyName];\n      return property[CREATE_EFFECT_METADATA_KEY].hasOwnProperty('dispatch');\n    }\n    return false;\n  }).map(propertyName => {\n    const metaData = instance[propertyName][CREATE_EFFECT_METADATA_KEY];\n    return Object.assign({\n      propertyName\n    }, metaData);\n  });\n  return metadata;\n}\nfunction getSourceForInstance(instance) {\n  return Object.getPrototypeOf(instance);\n}\nconst METADATA_KEY = '__@ngrx/effects__';\n/**\n * @deprecated The Effect decorator (`@Effect`) is deprecated in favor for the `createEffect` method.\n * See the docs for more info {@link https://ngrx.io/guide/migration/v11#the-effect-decorator}\n */\nfunction Effect(config = {}) {\n  return function (target, propertyName) {\n    const metadata = Object.assign(Object.assign(Object.assign({}, DEFAULT_EFFECT_CONFIG), config), {\n      // Overrides any defaults if values are provided\n      propertyName\n    });\n    addEffectMetadataEntry(target, metadata);\n  };\n}\nfunction getEffectDecoratorMetadata(instance) {\n  const effectsDecorators = compose(getEffectMetadataEntries, getSourceForInstance)(instance);\n  return effectsDecorators;\n}\n/**\n * Type guard to detemine whether METADATA_KEY is already present on the Class\n * constructor\n */\nfunction hasMetadataEntries(sourceProto) {\n  return sourceProto.constructor.hasOwnProperty(METADATA_KEY);\n}\n/** Add Effect Metadata to the Effect Class constructor under specific key */\nfunction addEffectMetadataEntry(sourceProto, metadata) {\n  if (hasMetadataEntries(sourceProto)) {\n    sourceProto.constructor[METADATA_KEY].push(metadata);\n  } else {\n    Object.defineProperty(sourceProto.constructor, METADATA_KEY, {\n      value: [metadata]\n    });\n  }\n}\nfunction getEffectMetadataEntries(sourceProto) {\n  return hasMetadataEntries(sourceProto) ? sourceProto.constructor[METADATA_KEY] : [];\n}\nfunction getEffectsMetadata(instance) {\n  return getSourceMetadata(instance).reduce((acc, {\n    propertyName,\n    dispatch,\n    useEffectsErrorHandler\n  }) => {\n    acc[propertyName] = {\n      dispatch,\n      useEffectsErrorHandler\n    };\n    return acc;\n  }, {});\n}\nfunction getSourceMetadata(instance) {\n  const effects = [getEffectDecoratorMetadata, getCreateEffectMetadata];\n  return effects.reduce((sources, source) => sources.concat(source(instance)), []);\n}\nfunction mergeEffects(sourceInstance, globalErrorHandler, effectsErrorHandler) {\n  const sourceName = getSourceForInstance(sourceInstance).constructor.name;\n  const observables$ = getSourceMetadata(sourceInstance).map(({\n    propertyName,\n    dispatch,\n    useEffectsErrorHandler\n  }) => {\n    const observable$ = typeof sourceInstance[propertyName] === 'function' ? sourceInstance[propertyName]() : sourceInstance[propertyName];\n    const effectAction$ = useEffectsErrorHandler ? effectsErrorHandler(observable$, globalErrorHandler) : observable$;\n    if (dispatch === false) {\n      return effectAction$.pipe(ignoreElements());\n    }\n    const materialized$ = effectAction$.pipe(materialize());\n    return materialized$.pipe(map(notification => ({\n      effect: sourceInstance[propertyName],\n      notification,\n      propertyName,\n      sourceName,\n      sourceInstance\n    })));\n  });\n  return merge(...observables$);\n}\nconst MAX_NUMBER_OF_RETRY_ATTEMPTS = 10;\nfunction defaultEffectsErrorHandler(observable$, errorHandler, retryAttemptLeft = MAX_NUMBER_OF_RETRY_ATTEMPTS) {\n  return observable$.pipe(catchError(error => {\n    if (errorHandler) errorHandler.handleError(error);\n    if (retryAttemptLeft <= 1) {\n      return observable$; // last attempt\n    }\n    // Return observable that produces this particular effect\n    return defaultEffectsErrorHandler(observable$, errorHandler, retryAttemptLeft - 1);\n  }));\n}\nclass Actions extends Observable {\n  constructor(source) {\n    super();\n    if (source) {\n      this.source = source;\n    }\n  }\n  lift(operator) {\n    const observable = new Actions();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n}\nActions.ɵfac = function Actions_Factory(t) {\n  return new (t || Actions)(ɵngcc0.ɵɵinject(ScannedActionsSubject));\n};\nActions.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: Actions,\n  factory: Actions.ɵfac\n});\n/** @nocollapse */\nActions.ctorParameters = () => [{\n  type: Observable,\n  decorators: [{\n    type: Inject,\n    args: [ScannedActionsSubject]\n  }]\n}];\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Actions, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ɵngcc1.Observable,\n      decorators: [{\n        type: Inject,\n        args: [ScannedActionsSubject]\n      }]\n    }];\n  }, null);\n})();\nfunction ofType(...allowedTypes) {\n  return filter(action => allowedTypes.some(typeOrActionCreator => {\n    if (typeof typeOrActionCreator === 'string') {\n      // Comparing the string to type\n      return typeOrActionCreator === action.type;\n    }\n    // We are filtering by ActionCreator\n    return typeOrActionCreator.type === action.type;\n  }));\n}\nfunction reportInvalidActions(output, reporter) {\n  if (output.notification.kind === 'N') {\n    const action = output.notification.value;\n    const isInvalidAction = !isAction(action);\n    if (isInvalidAction) {\n      reporter.handleError(new Error(`Effect ${getEffectName(output)} dispatched an invalid action: ${stringify(action)}`));\n    }\n  }\n}\nfunction isAction(action) {\n  return typeof action !== 'function' && action && action.type && typeof action.type === 'string';\n}\nfunction getEffectName({\n  propertyName,\n  sourceInstance,\n  sourceName\n}) {\n  const isMethod = typeof sourceInstance[propertyName] === 'function';\n  return `\"${sourceName}.${String(propertyName)}${isMethod ? '()' : ''}\"`;\n}\nfunction stringify(action) {\n  try {\n    return JSON.stringify(action);\n  } catch (_a) {\n    return action;\n  }\n}\nconst onIdentifyEffectsKey = 'ngrxOnIdentifyEffects';\nfunction isOnIdentifyEffects(instance) {\n  return isFunction(instance, onIdentifyEffectsKey);\n}\nconst onRunEffectsKey = 'ngrxOnRunEffects';\nfunction isOnRunEffects(instance) {\n  return isFunction(instance, onRunEffectsKey);\n}\nconst onInitEffects = 'ngrxOnInitEffects';\nfunction isOnInitEffects(instance) {\n  return isFunction(instance, onInitEffects);\n}\nfunction isFunction(instance, functionName) {\n  return instance && functionName in instance && typeof instance[functionName] === 'function';\n}\nconst _ROOT_EFFECTS_GUARD = new InjectionToken('@ngrx/effects Internal Root Guard');\nconst USER_PROVIDED_EFFECTS = new InjectionToken('@ngrx/effects User Provided Effects');\nconst _ROOT_EFFECTS = new InjectionToken('@ngrx/effects Internal Root Effects');\nconst ROOT_EFFECTS = new InjectionToken('@ngrx/effects Root Effects');\nconst _FEATURE_EFFECTS = new InjectionToken('@ngrx/effects Internal Feature Effects');\nconst FEATURE_EFFECTS = new InjectionToken('@ngrx/effects Feature Effects');\nconst EFFECTS_ERROR_HANDLER = new InjectionToken('@ngrx/effects Effects Error Handler');\nclass EffectSources extends Subject {\n  constructor(errorHandler, effectsErrorHandler) {\n    super();\n    this.errorHandler = errorHandler;\n    this.effectsErrorHandler = effectsErrorHandler;\n  }\n  addEffects(effectSourceInstance) {\n    this.next(effectSourceInstance);\n  }\n  /**\n   * @internal\n   */\n  toActions() {\n    return this.pipe(groupBy(getSourceForInstance), mergeMap(source$ => {\n      return source$.pipe(groupBy(effectsInstance));\n    }), mergeMap(source$ => {\n      const effect$ = source$.pipe(exhaustMap(sourceInstance => {\n        return resolveEffectSource(this.errorHandler, this.effectsErrorHandler)(sourceInstance);\n      }), map(output => {\n        reportInvalidActions(output, this.errorHandler);\n        return output.notification;\n      }), filter(notification => notification.kind === 'N' && notification.value != null), dematerialize());\n      // start the stream with an INIT action\n      // do this only for the first Effect instance\n      const init$ = source$.pipe(take(1), filter(isOnInitEffects), map(instance => instance.ngrxOnInitEffects()));\n      return merge(effect$, init$);\n    }));\n  }\n}\nEffectSources.ɵfac = function EffectSources_Factory(t) {\n  return new (t || EffectSources)(ɵngcc0.ɵɵinject(ɵngcc0.ErrorHandler), ɵngcc0.ɵɵinject(EFFECTS_ERROR_HANDLER));\n};\nEffectSources.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: EffectSources,\n  factory: EffectSources.ɵfac\n});\n/** @nocollapse */\nEffectSources.ctorParameters = () => [{\n  type: ErrorHandler\n}, {\n  type: undefined,\n  decorators: [{\n    type: Inject,\n    args: [EFFECTS_ERROR_HANDLER]\n  }]\n}];\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(EffectSources, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ɵngcc0.ErrorHandler\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [EFFECTS_ERROR_HANDLER]\n      }]\n    }];\n  }, null);\n})();\nfunction effectsInstance(sourceInstance) {\n  if (isOnIdentifyEffects(sourceInstance)) {\n    return sourceInstance.ngrxOnIdentifyEffects();\n  }\n  return '';\n}\nfunction resolveEffectSource(errorHandler, effectsErrorHandler) {\n  return sourceInstance => {\n    const mergedEffects$ = mergeEffects(sourceInstance, errorHandler, effectsErrorHandler);\n    if (isOnRunEffects(sourceInstance)) {\n      return sourceInstance.ngrxOnRunEffects(mergedEffects$);\n    }\n    return mergedEffects$;\n  };\n}\nclass EffectsRunner {\n  constructor(effectSources, store) {\n    this.effectSources = effectSources;\n    this.store = store;\n    this.effectsSubscription = null;\n  }\n  start() {\n    if (!this.effectsSubscription) {\n      this.effectsSubscription = this.effectSources.toActions().subscribe(this.store);\n    }\n  }\n  ngOnDestroy() {\n    if (this.effectsSubscription) {\n      this.effectsSubscription.unsubscribe();\n      this.effectsSubscription = null;\n    }\n  }\n}\nEffectsRunner.ɵfac = function EffectsRunner_Factory(t) {\n  return new (t || EffectsRunner)(ɵngcc0.ɵɵinject(EffectSources), ɵngcc0.ɵɵinject(ɵngcc2.Store));\n};\nEffectsRunner.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: EffectsRunner,\n  factory: EffectsRunner.ɵfac\n});\n/** @nocollapse */\nEffectsRunner.ctorParameters = () => [{\n  type: EffectSources\n}, {\n  type: Store\n}];\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(EffectsRunner, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: EffectSources\n    }, {\n      type: ɵngcc2.Store\n    }];\n  }, null);\n})();\nconst ROOT_EFFECTS_INIT = '@ngrx/effects/init';\nconst rootEffectsInit = createAction(ROOT_EFFECTS_INIT);\nclass EffectsRootModule {\n  constructor(sources, runner, store, rootEffects, storeRootModule, storeFeatureModule, guard) {\n    this.sources = sources;\n    runner.start();\n    rootEffects.forEach(effectSourceInstance => sources.addEffects(effectSourceInstance));\n    store.dispatch({\n      type: ROOT_EFFECTS_INIT\n    });\n  }\n  addEffects(effectSourceInstance) {\n    this.sources.addEffects(effectSourceInstance);\n  }\n}\nEffectsRootModule.ɵfac = function EffectsRootModule_Factory(t) {\n  return new (t || EffectsRootModule)(ɵngcc0.ɵɵinject(EffectSources), ɵngcc0.ɵɵinject(EffectsRunner), ɵngcc0.ɵɵinject(ɵngcc2.Store), ɵngcc0.ɵɵinject(ROOT_EFFECTS), ɵngcc0.ɵɵinject(ɵngcc2.StoreRootModule, 8), ɵngcc0.ɵɵinject(ɵngcc2.StoreFeatureModule, 8), ɵngcc0.ɵɵinject(_ROOT_EFFECTS_GUARD, 8));\n};\nEffectsRootModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n  type: EffectsRootModule\n});\nEffectsRootModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n/** @nocollapse */\nEffectsRootModule.ctorParameters = () => [{\n  type: EffectSources\n}, {\n  type: EffectsRunner\n}, {\n  type: Store\n}, {\n  type: Array,\n  decorators: [{\n    type: Inject,\n    args: [ROOT_EFFECTS]\n  }]\n}, {\n  type: StoreRootModule,\n  decorators: [{\n    type: Optional\n  }]\n}, {\n  type: StoreFeatureModule,\n  decorators: [{\n    type: Optional\n  }]\n}, {\n  type: undefined,\n  decorators: [{\n    type: Optional\n  }, {\n    type: Inject,\n    args: [_ROOT_EFFECTS_GUARD]\n  }]\n}];\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(EffectsRootModule, [{\n    type: NgModule,\n    args: [{}]\n  }], function () {\n    return [{\n      type: EffectSources\n    }, {\n      type: EffectsRunner\n    }, {\n      type: ɵngcc2.Store\n    }, {\n      type: Array,\n      decorators: [{\n        type: Inject,\n        args: [ROOT_EFFECTS]\n      }]\n    }, {\n      type: ɵngcc2.StoreRootModule,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: ɵngcc2.StoreFeatureModule,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [_ROOT_EFFECTS_GUARD]\n      }]\n    }];\n  }, null);\n})();\nclass EffectsFeatureModule {\n  constructor(root, effectSourceGroups, storeRootModule, storeFeatureModule) {\n    effectSourceGroups.forEach(group => group.forEach(effectSourceInstance => root.addEffects(effectSourceInstance)));\n  }\n}\nEffectsFeatureModule.ɵfac = function EffectsFeatureModule_Factory(t) {\n  return new (t || EffectsFeatureModule)(ɵngcc0.ɵɵinject(EffectsRootModule), ɵngcc0.ɵɵinject(FEATURE_EFFECTS), ɵngcc0.ɵɵinject(ɵngcc2.StoreRootModule, 8), ɵngcc0.ɵɵinject(ɵngcc2.StoreFeatureModule, 8));\n};\nEffectsFeatureModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n  type: EffectsFeatureModule\n});\nEffectsFeatureModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n/** @nocollapse */\nEffectsFeatureModule.ctorParameters = () => [{\n  type: EffectsRootModule\n}, {\n  type: Array,\n  decorators: [{\n    type: Inject,\n    args: [FEATURE_EFFECTS]\n  }]\n}, {\n  type: StoreRootModule,\n  decorators: [{\n    type: Optional\n  }]\n}, {\n  type: StoreFeatureModule,\n  decorators: [{\n    type: Optional\n  }]\n}];\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(EffectsFeatureModule, [{\n    type: NgModule,\n    args: [{}]\n  }], function () {\n    return [{\n      type: EffectsRootModule\n    }, {\n      type: Array,\n      decorators: [{\n        type: Inject,\n        args: [FEATURE_EFFECTS]\n      }]\n    }, {\n      type: ɵngcc2.StoreRootModule,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: ɵngcc2.StoreFeatureModule,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\nclass EffectsModule {\n  static forFeature(featureEffects = []) {\n    return {\n      ngModule: EffectsFeatureModule,\n      providers: [featureEffects, {\n        provide: _FEATURE_EFFECTS,\n        multi: true,\n        useValue: featureEffects\n      }, {\n        provide: USER_PROVIDED_EFFECTS,\n        multi: true,\n        useValue: []\n      }, {\n        provide: FEATURE_EFFECTS,\n        multi: true,\n        useFactory: createEffects,\n        deps: [Injector, _FEATURE_EFFECTS, USER_PROVIDED_EFFECTS]\n      }]\n    };\n  }\n  static forRoot(rootEffects = []) {\n    return {\n      ngModule: EffectsRootModule,\n      providers: [{\n        provide: EFFECTS_ERROR_HANDLER,\n        useValue: defaultEffectsErrorHandler\n      }, EffectsRunner, EffectSources, Actions, rootEffects, {\n        provide: _ROOT_EFFECTS,\n        useValue: [rootEffects]\n      }, {\n        provide: _ROOT_EFFECTS_GUARD,\n        useFactory: _provideForRootGuard,\n        deps: [[EffectsRunner, new Optional(), new SkipSelf()], [_ROOT_EFFECTS, new Self()]]\n      }, {\n        provide: USER_PROVIDED_EFFECTS,\n        multi: true,\n        useValue: []\n      }, {\n        provide: ROOT_EFFECTS,\n        useFactory: createEffects,\n        deps: [Injector, _ROOT_EFFECTS, USER_PROVIDED_EFFECTS]\n      }]\n    };\n  }\n}\nEffectsModule.ɵfac = function EffectsModule_Factory(t) {\n  return new (t || EffectsModule)();\n};\nEffectsModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n  type: EffectsModule\n});\nEffectsModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(EffectsModule, [{\n    type: NgModule,\n    args: [{}]\n  }], null, null);\n})();\nfunction createEffects(injector, effectGroups, userProvidedEffectGroups) {\n  const mergedEffects = [];\n  for (const effectGroup of effectGroups) {\n    mergedEffects.push(...effectGroup);\n  }\n  for (const userProvidedEffectGroup of userProvidedEffectGroups) {\n    mergedEffects.push(...userProvidedEffectGroup);\n  }\n  return createEffectInstances(injector, mergedEffects);\n}\nfunction createEffectInstances(injector, effects) {\n  return effects.map(effect => injector.get(effect));\n}\nfunction _provideForRootGuard(runner, rootEffects) {\n  // check whether any effects are actually passed\n  const hasEffects = !(rootEffects.length === 1 && rootEffects[0].length === 0);\n  if (hasEffects && runner) {\n    throw new TypeError(`EffectsModule.forRoot() called twice. Feature modules should use EffectsModule.forFeature() instead.`);\n  }\n  return 'guarded';\n}\nfunction act( /** Allow to take either config object or project/error functions */\nconfigOrProject, errorFn) {\n  const {\n    project,\n    error,\n    complete,\n    operator,\n    unsubscribe\n  } = typeof configOrProject === 'function' ? {\n    project: configOrProject,\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    error: errorFn,\n    operator: concatMap,\n    complete: undefined,\n    unsubscribe: undefined\n  } : Object.assign(Object.assign({}, configOrProject), {\n    operator: configOrProject.operator || concatMap\n  });\n  return source => defer(() => {\n    const subject = new Subject();\n    return merge(source.pipe(operator((input, index) => defer(() => {\n      let completed = false;\n      let errored = false;\n      let projectedCount = 0;\n      return project(input, index).pipe(materialize(), map(notification => {\n        switch (notification.kind) {\n          case 'E':\n            errored = true;\n            return new Notification('N', error(notification.error, input));\n          case 'C':\n            completed = true;\n            return complete ? new Notification('N', complete(projectedCount, input)) : undefined;\n          default:\n            ++projectedCount;\n            return notification;\n        }\n      }), filter(n => n != null), dematerialize(), finalize(() => {\n        if (!completed && !errored && unsubscribe) {\n          subject.next(unsubscribe(projectedCount, input));\n        }\n      }));\n    }))), subject);\n  });\n}\n\n/**\n * 'concatLatestFrom' combines the source value\n * and the last available value from a lazily evaluated Observable\n * in a new array\n */\nfunction concatLatestFrom(observablesFactory) {\n  return pipe(concatMap(value => {\n    const observables = observablesFactory(value);\n    const observablesAsArray = Array.isArray(observables) ? observables : [observables];\n    return of(value).pipe(withLatestFrom(...observablesAsArray));\n  }));\n}\n\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Actions, EFFECTS_ERROR_HANDLER, Effect, EffectSources, EffectsFeatureModule, EffectsModule, EffectsRootModule, EffectsRunner, ROOT_EFFECTS_INIT, USER_PROVIDED_EFFECTS, act, concatLatestFrom, createEffect, defaultEffectsErrorHandler, getEffectsMetadata, mergeEffects, ofType, rootEffectsInit, getSourceMetadata as ɵa, createEffects as ɵb, _provideForRootGuard as ɵc, _ROOT_EFFECTS_GUARD as ɵd, _ROOT_EFFECTS as ɵe, ROOT_EFFECTS as ɵf, _FEATURE_EFFECTS as ɵg, FEATURE_EFFECTS as ɵh };","map":{"version":3,"names":["compose","ScannedActionsSubject","Store","createAction","StoreRootModule","StoreFeatureModule","merge","Observable","Subject","defer","Notification","pipe","of","ignoreElements","materialize","map","catchError","filter","groupBy","mergeMap","exhaustMap","dematerialize","take","concatMap","finalize","withLatestFrom","Injectable","Inject","InjectionToken","ErrorHandler","NgModule","Optional","Injector","SkipSelf","Self","ɵngcc0","ɵngcc1","ɵngcc2","DEFAULT_EFFECT_CONFIG","dispatch","useEffectsErrorHandler","CREATE_EFFECT_METADATA_KEY","createEffect","source","config","effect","value","Object","assign","defineProperty","getCreateEffectMetadata","instance","propertyNames","getOwnPropertyNames","metadata","propertyName","hasOwnProperty","property","metaData","getSourceForInstance","getPrototypeOf","METADATA_KEY","Effect","target","addEffectMetadataEntry","getEffectDecoratorMetadata","effectsDecorators","getEffectMetadataEntries","hasMetadataEntries","sourceProto","constructor","push","getEffectsMetadata","getSourceMetadata","reduce","acc","effects","sources","concat","mergeEffects","sourceInstance","globalErrorHandler","effectsErrorHandler","sourceName","name","observables$","observable$","effectAction$","materialized$","notification","MAX_NUMBER_OF_RETRY_ATTEMPTS","defaultEffectsErrorHandler","errorHandler","retryAttemptLeft","error","handleError","Actions","lift","operator","observable","ɵfac","Actions_Factory","t","ɵɵinject","ɵprov","ɵɵdefineInjectable","token","factory","ctorParameters","type","decorators","args","ngDevMode","ɵsetClassMetadata","ofType","allowedTypes","action","some","typeOrActionCreator","reportInvalidActions","output","reporter","kind","isInvalidAction","isAction","Error","getEffectName","stringify","isMethod","String","JSON","_a","onIdentifyEffectsKey","isOnIdentifyEffects","isFunction","onRunEffectsKey","isOnRunEffects","onInitEffects","isOnInitEffects","functionName","_ROOT_EFFECTS_GUARD","USER_PROVIDED_EFFECTS","_ROOT_EFFECTS","ROOT_EFFECTS","_FEATURE_EFFECTS","FEATURE_EFFECTS","EFFECTS_ERROR_HANDLER","EffectSources","addEffects","effectSourceInstance","next","toActions","source$","effectsInstance","effect$","resolveEffectSource","init$","ngrxOnInitEffects","EffectSources_Factory","undefined","ngrxOnIdentifyEffects","mergedEffects$","ngrxOnRunEffects","EffectsRunner","effectSources","store","effectsSubscription","start","subscribe","ngOnDestroy","unsubscribe","EffectsRunner_Factory","ROOT_EFFECTS_INIT","rootEffectsInit","EffectsRootModule","runner","rootEffects","storeRootModule","storeFeatureModule","guard","forEach","EffectsRootModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","Array","EffectsFeatureModule","root","effectSourceGroups","group","EffectsFeatureModule_Factory","EffectsModule","forFeature","featureEffects","ngModule","providers","provide","multi","useValue","useFactory","createEffects","deps","forRoot","_provideForRootGuard","EffectsModule_Factory","injector","effectGroups","userProvidedEffectGroups","mergedEffects","effectGroup","userProvidedEffectGroup","createEffectInstances","get","hasEffects","length","TypeError","act","configOrProject","errorFn","project","complete","subject","input","index","completed","errored","projectedCount","n","concatLatestFrom","observablesFactory","observables","observablesAsArray","isArray","ɵa","ɵb","ɵc","ɵd","ɵe","ɵf","ɵg","ɵh"],"sources":["C:/Users/Vongai/Vongai Code/Microsoft courses/my-static-web-app-and-api/angular-app/node_modules/@ngrx/effects/__ivy_ngcc__/fesm2015/ngrx-effects.js"],"sourcesContent":["import { compose, ScannedActionsSubject, Store, createAction, StoreRootModule, StoreFeatureModule } from '@ngrx/store';\nimport { merge, Observable, Subject, defer, Notification, pipe, of } from 'rxjs';\nimport { ignoreElements, materialize, map, catchError, filter, groupBy, mergeMap, exhaustMap, dematerialize, take, concatMap, finalize, withLatestFrom } from 'rxjs/operators';\nimport { Injectable, Inject, InjectionToken, ErrorHandler, NgModule, Optional, Injector, SkipSelf, Self } from '@angular/core';\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from 'rxjs';\nimport * as ɵngcc2 from '@ngrx/store';\nconst DEFAULT_EFFECT_CONFIG = {\n    dispatch: true,\n    useEffectsErrorHandler: true,\n};\nconst CREATE_EFFECT_METADATA_KEY = '__@ngrx/effects_create__';\n\n/**\n * @description\n * Creates an effect from an `Observable` and an `EffectConfig`.\n *\n * @param source A function which returns an `Observable`.\n * @param config A `Partial<EffectConfig>` to configure the effect.  By default, `dispatch` is true and `useEffectsErrorHandler` is true.\n * @returns If `EffectConfig`#`dispatch` is true, returns `Observable<Action>`.  Else, returns `Observable<unknown>`.\n *\n * @usageNotes\n *\n * ** Mapping to a different action **\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(FeatureActions.actionOne),\n *     map(() => FeatureActions.actionTwo())\n *   )\n * );\n * ```\n *\n *  ** Non-dispatching effects **\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(FeatureActions.actionOne),\n *     tap(() => console.log('Action One Dispatched'))\n *   ),\n *   { dispatch: false }\n *   // FeatureActions.actionOne is not dispatched\n * );\n * ```\n */\nfunction createEffect(source, config) {\n    const effect = source();\n    const value = Object.assign(Object.assign({}, DEFAULT_EFFECT_CONFIG), config);\n    Object.defineProperty(effect, CREATE_EFFECT_METADATA_KEY, {\n        value,\n    });\n    return effect;\n}\nfunction getCreateEffectMetadata(instance) {\n    const propertyNames = Object.getOwnPropertyNames(instance);\n    const metadata = propertyNames\n        .filter((propertyName) => {\n        if (instance[propertyName] &&\n            instance[propertyName].hasOwnProperty(CREATE_EFFECT_METADATA_KEY)) {\n            // If the property type has overridden `hasOwnProperty` we need to ensure\n            // that the metadata is valid (containing a `dispatch`property)\n            // https://github.com/ngrx/platform/issues/2975\n            const property = instance[propertyName];\n            return property[CREATE_EFFECT_METADATA_KEY].hasOwnProperty('dispatch');\n        }\n        return false;\n    })\n        .map((propertyName) => {\n        const metaData = instance[propertyName][CREATE_EFFECT_METADATA_KEY];\n        return Object.assign({ propertyName }, metaData);\n    });\n    return metadata;\n}\n\nfunction getSourceForInstance(instance) {\n    return Object.getPrototypeOf(instance);\n}\n\nconst METADATA_KEY = '__@ngrx/effects__';\n/**\n * @deprecated The Effect decorator (`@Effect`) is deprecated in favor for the `createEffect` method.\n * See the docs for more info {@link https://ngrx.io/guide/migration/v11#the-effect-decorator}\n */\nfunction Effect(config = {}) {\n    return function (target, propertyName) {\n        const metadata = Object.assign(Object.assign(Object.assign({}, DEFAULT_EFFECT_CONFIG), config), { // Overrides any defaults if values are provided\n            propertyName });\n        addEffectMetadataEntry(target, metadata);\n    };\n}\nfunction getEffectDecoratorMetadata(instance) {\n    const effectsDecorators = compose(getEffectMetadataEntries, getSourceForInstance)(instance);\n    return effectsDecorators;\n}\n/**\n * Type guard to detemine whether METADATA_KEY is already present on the Class\n * constructor\n */\nfunction hasMetadataEntries(sourceProto) {\n    return sourceProto.constructor.hasOwnProperty(METADATA_KEY);\n}\n/** Add Effect Metadata to the Effect Class constructor under specific key */\nfunction addEffectMetadataEntry(sourceProto, metadata) {\n    if (hasMetadataEntries(sourceProto)) {\n        sourceProto.constructor[METADATA_KEY].push(metadata);\n    }\n    else {\n        Object.defineProperty(sourceProto.constructor, METADATA_KEY, {\n            value: [metadata],\n        });\n    }\n}\nfunction getEffectMetadataEntries(sourceProto) {\n    return hasMetadataEntries(sourceProto)\n        ? sourceProto.constructor[METADATA_KEY]\n        : [];\n}\n\nfunction getEffectsMetadata(instance) {\n    return getSourceMetadata(instance).reduce((acc, { propertyName, dispatch, useEffectsErrorHandler }) => {\n        acc[propertyName] = { dispatch, useEffectsErrorHandler };\n        return acc;\n    }, {});\n}\nfunction getSourceMetadata(instance) {\n    const effects = [\n        getEffectDecoratorMetadata,\n        getCreateEffectMetadata,\n    ];\n    return effects.reduce((sources, source) => sources.concat(source(instance)), []);\n}\n\nfunction mergeEffects(sourceInstance, globalErrorHandler, effectsErrorHandler) {\n    const sourceName = getSourceForInstance(sourceInstance).constructor.name;\n    const observables$ = getSourceMetadata(sourceInstance).map(({ propertyName, dispatch, useEffectsErrorHandler, }) => {\n        const observable$ = typeof sourceInstance[propertyName] === 'function'\n            ? sourceInstance[propertyName]()\n            : sourceInstance[propertyName];\n        const effectAction$ = useEffectsErrorHandler\n            ? effectsErrorHandler(observable$, globalErrorHandler)\n            : observable$;\n        if (dispatch === false) {\n            return effectAction$.pipe(ignoreElements());\n        }\n        const materialized$ = effectAction$.pipe(materialize());\n        return materialized$.pipe(map((notification) => ({\n            effect: sourceInstance[propertyName],\n            notification,\n            propertyName,\n            sourceName,\n            sourceInstance,\n        })));\n    });\n    return merge(...observables$);\n}\n\nconst MAX_NUMBER_OF_RETRY_ATTEMPTS = 10;\nfunction defaultEffectsErrorHandler(observable$, errorHandler, retryAttemptLeft = MAX_NUMBER_OF_RETRY_ATTEMPTS) {\n    return observable$.pipe(catchError((error) => {\n        if (errorHandler)\n            errorHandler.handleError(error);\n        if (retryAttemptLeft <= 1) {\n            return observable$; // last attempt\n        }\n        // Return observable that produces this particular effect\n        return defaultEffectsErrorHandler(observable$, errorHandler, retryAttemptLeft - 1);\n    }));\n}\n\nclass Actions extends Observable {\n    constructor(source) {\n        super();\n        if (source) {\n            this.source = source;\n        }\n    }\n    lift(operator) {\n        const observable = new Actions();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    }\n}\nActions.ɵfac = function Actions_Factory(t) { return new (t || Actions)(ɵngcc0.ɵɵinject(ScannedActionsSubject)); };\nActions.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: Actions, factory: Actions.ɵfac });\n/** @nocollapse */\nActions.ctorParameters = () => [\n    { type: Observable, decorators: [{ type: Inject, args: [ScannedActionsSubject,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Actions, [{\n        type: Injectable\n    }], function () { return [{ type: ɵngcc1.Observable, decorators: [{\n                type: Inject,\n                args: [ScannedActionsSubject]\n            }] }]; }, null); })();\nfunction ofType(...allowedTypes) {\n    return filter((action) => allowedTypes.some((typeOrActionCreator) => {\n        if (typeof typeOrActionCreator === 'string') {\n            // Comparing the string to type\n            return typeOrActionCreator === action.type;\n        }\n        // We are filtering by ActionCreator\n        return typeOrActionCreator.type === action.type;\n    }));\n}\n\nfunction reportInvalidActions(output, reporter) {\n    if (output.notification.kind === 'N') {\n        const action = output.notification.value;\n        const isInvalidAction = !isAction(action);\n        if (isInvalidAction) {\n            reporter.handleError(new Error(`Effect ${getEffectName(output)} dispatched an invalid action: ${stringify(action)}`));\n        }\n    }\n}\nfunction isAction(action) {\n    return (typeof action !== 'function' &&\n        action &&\n        action.type &&\n        typeof action.type === 'string');\n}\nfunction getEffectName({ propertyName, sourceInstance, sourceName, }) {\n    const isMethod = typeof sourceInstance[propertyName] === 'function';\n    return `\"${sourceName}.${String(propertyName)}${isMethod ? '()' : ''}\"`;\n}\nfunction stringify(action) {\n    try {\n        return JSON.stringify(action);\n    }\n    catch (_a) {\n        return action;\n    }\n}\n\nconst onIdentifyEffectsKey = 'ngrxOnIdentifyEffects';\nfunction isOnIdentifyEffects(instance) {\n    return isFunction(instance, onIdentifyEffectsKey);\n}\nconst onRunEffectsKey = 'ngrxOnRunEffects';\nfunction isOnRunEffects(instance) {\n    return isFunction(instance, onRunEffectsKey);\n}\nconst onInitEffects = 'ngrxOnInitEffects';\nfunction isOnInitEffects(instance) {\n    return isFunction(instance, onInitEffects);\n}\nfunction isFunction(instance, functionName) {\n    return (instance &&\n        functionName in instance &&\n        typeof instance[functionName] === 'function');\n}\n\nconst _ROOT_EFFECTS_GUARD = new InjectionToken('@ngrx/effects Internal Root Guard');\nconst USER_PROVIDED_EFFECTS = new InjectionToken('@ngrx/effects User Provided Effects');\nconst _ROOT_EFFECTS = new InjectionToken('@ngrx/effects Internal Root Effects');\nconst ROOT_EFFECTS = new InjectionToken('@ngrx/effects Root Effects');\nconst _FEATURE_EFFECTS = new InjectionToken('@ngrx/effects Internal Feature Effects');\nconst FEATURE_EFFECTS = new InjectionToken('@ngrx/effects Feature Effects');\nconst EFFECTS_ERROR_HANDLER = new InjectionToken('@ngrx/effects Effects Error Handler');\n\nclass EffectSources extends Subject {\n    constructor(errorHandler, effectsErrorHandler) {\n        super();\n        this.errorHandler = errorHandler;\n        this.effectsErrorHandler = effectsErrorHandler;\n    }\n    addEffects(effectSourceInstance) {\n        this.next(effectSourceInstance);\n    }\n    /**\n     * @internal\n     */\n    toActions() {\n        return this.pipe(groupBy(getSourceForInstance), mergeMap((source$) => {\n            return source$.pipe(groupBy(effectsInstance));\n        }), mergeMap((source$) => {\n            const effect$ = source$.pipe(exhaustMap((sourceInstance) => {\n                return resolveEffectSource(this.errorHandler, this.effectsErrorHandler)(sourceInstance);\n            }), map((output) => {\n                reportInvalidActions(output, this.errorHandler);\n                return output.notification;\n            }), filter((notification) => notification.kind === 'N' && notification.value != null), dematerialize());\n            // start the stream with an INIT action\n            // do this only for the first Effect instance\n            const init$ = source$.pipe(take(1), filter(isOnInitEffects), map((instance) => instance.ngrxOnInitEffects()));\n            return merge(effect$, init$);\n        }));\n    }\n}\nEffectSources.ɵfac = function EffectSources_Factory(t) { return new (t || EffectSources)(ɵngcc0.ɵɵinject(ɵngcc0.ErrorHandler), ɵngcc0.ɵɵinject(EFFECTS_ERROR_HANDLER)); };\nEffectSources.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: EffectSources, factory: EffectSources.ɵfac });\n/** @nocollapse */\nEffectSources.ctorParameters = () => [\n    { type: ErrorHandler },\n    { type: undefined, decorators: [{ type: Inject, args: [EFFECTS_ERROR_HANDLER,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(EffectSources, [{\n        type: Injectable\n    }], function () { return [{ type: ɵngcc0.ErrorHandler }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [EFFECTS_ERROR_HANDLER]\n            }] }]; }, null); })();\nfunction effectsInstance(sourceInstance) {\n    if (isOnIdentifyEffects(sourceInstance)) {\n        return sourceInstance.ngrxOnIdentifyEffects();\n    }\n    return '';\n}\nfunction resolveEffectSource(errorHandler, effectsErrorHandler) {\n    return (sourceInstance) => {\n        const mergedEffects$ = mergeEffects(sourceInstance, errorHandler, effectsErrorHandler);\n        if (isOnRunEffects(sourceInstance)) {\n            return sourceInstance.ngrxOnRunEffects(mergedEffects$);\n        }\n        return mergedEffects$;\n    };\n}\n\nclass EffectsRunner {\n    constructor(effectSources, store) {\n        this.effectSources = effectSources;\n        this.store = store;\n        this.effectsSubscription = null;\n    }\n    start() {\n        if (!this.effectsSubscription) {\n            this.effectsSubscription = this.effectSources\n                .toActions()\n                .subscribe(this.store);\n        }\n    }\n    ngOnDestroy() {\n        if (this.effectsSubscription) {\n            this.effectsSubscription.unsubscribe();\n            this.effectsSubscription = null;\n        }\n    }\n}\nEffectsRunner.ɵfac = function EffectsRunner_Factory(t) { return new (t || EffectsRunner)(ɵngcc0.ɵɵinject(EffectSources), ɵngcc0.ɵɵinject(ɵngcc2.Store)); };\nEffectsRunner.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: EffectsRunner, factory: EffectsRunner.ɵfac });\n/** @nocollapse */\nEffectsRunner.ctorParameters = () => [\n    { type: EffectSources },\n    { type: Store }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(EffectsRunner, [{\n        type: Injectable\n    }], function () { return [{ type: EffectSources }, { type: ɵngcc2.Store }]; }, null); })();\n\nconst ROOT_EFFECTS_INIT = '@ngrx/effects/init';\nconst rootEffectsInit = createAction(ROOT_EFFECTS_INIT);\nclass EffectsRootModule {\n    constructor(sources, runner, store, rootEffects, storeRootModule, storeFeatureModule, guard) {\n        this.sources = sources;\n        runner.start();\n        rootEffects.forEach((effectSourceInstance) => sources.addEffects(effectSourceInstance));\n        store.dispatch({ type: ROOT_EFFECTS_INIT });\n    }\n    addEffects(effectSourceInstance) {\n        this.sources.addEffects(effectSourceInstance);\n    }\n}\nEffectsRootModule.ɵfac = function EffectsRootModule_Factory(t) { return new (t || EffectsRootModule)(ɵngcc0.ɵɵinject(EffectSources), ɵngcc0.ɵɵinject(EffectsRunner), ɵngcc0.ɵɵinject(ɵngcc2.Store), ɵngcc0.ɵɵinject(ROOT_EFFECTS), ɵngcc0.ɵɵinject(ɵngcc2.StoreRootModule, 8), ɵngcc0.ɵɵinject(ɵngcc2.StoreFeatureModule, 8), ɵngcc0.ɵɵinject(_ROOT_EFFECTS_GUARD, 8)); };\nEffectsRootModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: EffectsRootModule });\nEffectsRootModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});\n/** @nocollapse */\nEffectsRootModule.ctorParameters = () => [\n    { type: EffectSources },\n    { type: EffectsRunner },\n    { type: Store },\n    { type: Array, decorators: [{ type: Inject, args: [ROOT_EFFECTS,] }] },\n    { type: StoreRootModule, decorators: [{ type: Optional }] },\n    { type: StoreFeatureModule, decorators: [{ type: Optional }] },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [_ROOT_EFFECTS_GUARD,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(EffectsRootModule, [{\n        type: NgModule,\n        args: [{}]\n    }], function () { return [{ type: EffectSources }, { type: EffectsRunner }, { type: ɵngcc2.Store }, { type: Array, decorators: [{\n                type: Inject,\n                args: [ROOT_EFFECTS]\n            }] }, { type: ɵngcc2.StoreRootModule, decorators: [{\n                type: Optional\n            }] }, { type: ɵngcc2.StoreFeatureModule, decorators: [{\n                type: Optional\n            }] }, { type: undefined, decorators: [{\n                type: Optional\n            }, {\n                type: Inject,\n                args: [_ROOT_EFFECTS_GUARD]\n            }] }]; }, null); })();\n\nclass EffectsFeatureModule {\n    constructor(root, effectSourceGroups, storeRootModule, storeFeatureModule) {\n        effectSourceGroups.forEach((group) => group.forEach((effectSourceInstance) => root.addEffects(effectSourceInstance)));\n    }\n}\nEffectsFeatureModule.ɵfac = function EffectsFeatureModule_Factory(t) { return new (t || EffectsFeatureModule)(ɵngcc0.ɵɵinject(EffectsRootModule), ɵngcc0.ɵɵinject(FEATURE_EFFECTS), ɵngcc0.ɵɵinject(ɵngcc2.StoreRootModule, 8), ɵngcc0.ɵɵinject(ɵngcc2.StoreFeatureModule, 8)); };\nEffectsFeatureModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: EffectsFeatureModule });\nEffectsFeatureModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});\n/** @nocollapse */\nEffectsFeatureModule.ctorParameters = () => [\n    { type: EffectsRootModule },\n    { type: Array, decorators: [{ type: Inject, args: [FEATURE_EFFECTS,] }] },\n    { type: StoreRootModule, decorators: [{ type: Optional }] },\n    { type: StoreFeatureModule, decorators: [{ type: Optional }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(EffectsFeatureModule, [{\n        type: NgModule,\n        args: [{}]\n    }], function () { return [{ type: EffectsRootModule }, { type: Array, decorators: [{\n                type: Inject,\n                args: [FEATURE_EFFECTS]\n            }] }, { type: ɵngcc2.StoreRootModule, decorators: [{\n                type: Optional\n            }] }, { type: ɵngcc2.StoreFeatureModule, decorators: [{\n                type: Optional\n            }] }]; }, null); })();\n\nclass EffectsModule {\n    static forFeature(featureEffects = []) {\n        return {\n            ngModule: EffectsFeatureModule,\n            providers: [\n                featureEffects,\n                {\n                    provide: _FEATURE_EFFECTS,\n                    multi: true,\n                    useValue: featureEffects,\n                },\n                {\n                    provide: USER_PROVIDED_EFFECTS,\n                    multi: true,\n                    useValue: [],\n                },\n                {\n                    provide: FEATURE_EFFECTS,\n                    multi: true,\n                    useFactory: createEffects,\n                    deps: [Injector, _FEATURE_EFFECTS, USER_PROVIDED_EFFECTS],\n                },\n            ],\n        };\n    }\n    static forRoot(rootEffects = []) {\n        return {\n            ngModule: EffectsRootModule,\n            providers: [\n                {\n                    provide: EFFECTS_ERROR_HANDLER,\n                    useValue: defaultEffectsErrorHandler,\n                },\n                EffectsRunner,\n                EffectSources,\n                Actions,\n                rootEffects,\n                {\n                    provide: _ROOT_EFFECTS,\n                    useValue: [rootEffects],\n                },\n                {\n                    provide: _ROOT_EFFECTS_GUARD,\n                    useFactory: _provideForRootGuard,\n                    deps: [\n                        [EffectsRunner, new Optional(), new SkipSelf()],\n                        [_ROOT_EFFECTS, new Self()],\n                    ],\n                },\n                {\n                    provide: USER_PROVIDED_EFFECTS,\n                    multi: true,\n                    useValue: [],\n                },\n                {\n                    provide: ROOT_EFFECTS,\n                    useFactory: createEffects,\n                    deps: [Injector, _ROOT_EFFECTS, USER_PROVIDED_EFFECTS],\n                },\n            ],\n        };\n    }\n}\nEffectsModule.ɵfac = function EffectsModule_Factory(t) { return new (t || EffectsModule)(); };\nEffectsModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: EffectsModule });\nEffectsModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(EffectsModule, [{\n        type: NgModule,\n        args: [{}]\n    }], null, null); })();\nfunction createEffects(injector, effectGroups, userProvidedEffectGroups) {\n    const mergedEffects = [];\n    for (const effectGroup of effectGroups) {\n        mergedEffects.push(...effectGroup);\n    }\n    for (const userProvidedEffectGroup of userProvidedEffectGroups) {\n        mergedEffects.push(...userProvidedEffectGroup);\n    }\n    return createEffectInstances(injector, mergedEffects);\n}\nfunction createEffectInstances(injector, effects) {\n    return effects.map((effect) => injector.get(effect));\n}\nfunction _provideForRootGuard(runner, rootEffects) {\n    // check whether any effects are actually passed\n    const hasEffects = !(rootEffects.length === 1 && rootEffects[0].length === 0);\n    if (hasEffects && runner) {\n        throw new TypeError(`EffectsModule.forRoot() called twice. Feature modules should use EffectsModule.forFeature() instead.`);\n    }\n    return 'guarded';\n}\n\nfunction act(\n/** Allow to take either config object or project/error functions */\nconfigOrProject, errorFn) {\n    const { project, error, complete, operator, unsubscribe } = typeof configOrProject === 'function'\n        ? {\n            project: configOrProject,\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            error: errorFn,\n            operator: concatMap,\n            complete: undefined,\n            unsubscribe: undefined,\n        }\n        : Object.assign(Object.assign({}, configOrProject), { operator: configOrProject.operator || concatMap });\n    return (source) => defer(() => {\n        const subject = new Subject();\n        return merge(source.pipe(operator((input, index) => defer(() => {\n            let completed = false;\n            let errored = false;\n            let projectedCount = 0;\n            return project(input, index).pipe(materialize(), map((notification) => {\n                switch (notification.kind) {\n                    case 'E':\n                        errored = true;\n                        return new Notification('N', error(notification.error, input));\n                    case 'C':\n                        completed = true;\n                        return complete\n                            ? new Notification('N', complete(projectedCount, input))\n                            : undefined;\n                    default:\n                        ++projectedCount;\n                        return notification;\n                }\n            }), filter((n) => n != null), dematerialize(), finalize(() => {\n                if (!completed && !errored && unsubscribe) {\n                    subject.next(unsubscribe(projectedCount, input));\n                }\n            }));\n        }))), subject);\n    });\n}\n\n/**\n * 'concatLatestFrom' combines the source value\n * and the last available value from a lazily evaluated Observable\n * in a new array\n */\nfunction concatLatestFrom(observablesFactory) {\n    return pipe(concatMap((value) => {\n        const observables = observablesFactory(value);\n        const observablesAsArray = Array.isArray(observables)\n            ? observables\n            : [observables];\n        return of(value).pipe(withLatestFrom(...observablesAsArray));\n    }));\n}\n\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Actions, EFFECTS_ERROR_HANDLER, Effect, EffectSources, EffectsFeatureModule, EffectsModule, EffectsRootModule, EffectsRunner, ROOT_EFFECTS_INIT, USER_PROVIDED_EFFECTS, act, concatLatestFrom, createEffect, defaultEffectsErrorHandler, getEffectsMetadata, mergeEffects, ofType, rootEffectsInit, getSourceMetadata as ɵa, createEffects as ɵb, _provideForRootGuard as ɵc, _ROOT_EFFECTS_GUARD as ɵd, _ROOT_EFFECTS as ɵe, ROOT_EFFECTS as ɵf, _FEATURE_EFFECTS as ɵg, FEATURE_EFFECTS as ɵh };\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}